<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F12%2F03%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL数据库MySQL属于C/S架构 联系的类型 一对一(1:1) 一对多(1:n) 多对多(m:n) 数据完整性规则 实体（行）完整性 域（列）完整性 参照完整性 设计范式数据库范式主要⽤于消除数据冗余，更新异常，插⼊异常和删除异常。 ⽬前关系数据库有六种范式： 第⼀范式（1NF） 、第⼆范式（2NF） 、第三范式（3NF） 、巴斯-科德范式（BCNF） 、第四范式(4NF） 和第五范式（5NF，⼜称完美范式）。 1NF：无重复的列，每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，就是无重复的列说明：第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库 2NF：在1NF的基础上，所有的⾮主属性必须完全依赖于主属性（主键）。属性完全依赖于主键，第二范式必须先满足第一范式，要求表中的每个行必须可以被唯一地区分。通常为表加上一个列，以存储各个实例的唯一标识PK，非PK的字段需要与整个PK有直接相关性 3NF：在2NF基础上，表中的⾮主属性字段不能依赖于其他的⾮主属性字段，否则新建表。属性不依赖于其它非主属性，满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主关键字信息，非PK的字段间不能有从属关系 BCNF：在3NF基础上，任何⾮主属性不能对主键⼦集依赖。 4NF：在3NF基础上 表中不能包含⼀个实体的两个或多个互相独⽴的多值因⼦。⽐如移动电话和固定电话 ,两个相互独⽴，有些⼈有多个移动电话或固定电话,存在⼀个表中违反4NF,应该新建表。 5NF：在4NF基础上，表必须可以分解为较⼩的表，除⾮那些表在逻辑上拥有与原始表相同的主键。例如供销表(产品，销售，供货商)可能会产⽣冗余，应该分解成销售表(销售，产品)，供货表(销售，供货商)，产品表((供货商，产品) 约束约束：constraint，表中的数据要遵守的限制 主键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；必须提供数据，即NOT NULL，一个表只能有一个 惟一键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；允许为NULL，一个表可以存在多个 外键：一个表中的某字段可填入的数据取决于另一个表的主键或唯一键已有的数据 检查：字段值在一定范围内 MySQL体系结构 MySQL存储引擎 MyISAM Memory InnoDB Archive NDB OQGraph SphinxSE TokuDB Cassandra CONNECT SQUENCE MyISAM 与 InnoDB MyISAM 不支持事务 表级锁 读写阻塞，写入时不能读，读出时不能写 只缓存索引不缓存数据 索引与数据分离存储 不支持外键约束 不支持聚簇索引 占用资源少，读取速度快 不支持MVCC（多版本并发控制机制）高并发 崩溃恢复性较差 MySQL5.5.5前默认的数据库引擎 MyISAM存储引擎使用场景：读较多，表较小 MyISAM引擎文件 tbl_name.frm 表格式定义 tbl_name.MYD 数据文件 tbl_name.MYI 索引文件 InnoDB 支持事务 行级锁，锁的粒度小，并发性影响小 读写阻塞与事务隔离级别相关 即缓存索引又缓存数据 索引与数据存储在同一文件（ibd） 支持外键约束 支持聚簇索引 支持MVCC高并发 崩溃恢复性更好 MySQL5.5后支持全文索引 MySQL5.5.5开始成为默认的数据库引擎 InnoDB引擎文件 tbl_name.frm 表格式文件 tbl_name.ibd 数据文件（存储数据和索引） MySQL中的系统数据库 mysql数据库：MySQL的核心数据库，主要负责存储数据库的用户、权限设置、关键字等MySQL自己需要使用的控制和管理信息 performance_schema数据库：主要用于收集数据库服务器性能参数，库里表的存储引擎均为performance_schema,用户不能创建存储引擎为performance_schema的表 information_schema数据库：是一个虚拟数据库，物理上并不存在，它类似于“数据字典”，提供了访问数据库元数据的方式，即数据的数据。比如数据库名或表名，列类型，访问权限 DDL语言创建数据库CREATE DATABASE|SCHEMA [IF NOT EXISTS] ‘DB_NAME’;CHARACTER SET ‘character set name’COLLATE ‘collate name’ create database studentdb; 删除数据库DROP DATABASE|SCHEMA [IF EXISTS] ‘DB_NAME’;drop database testdb; 创建表CREATE TABLE [IF NOT EXISTS] ‘tbl_name’ (col1 type1 修饰符, col2 type2 修饰符, …) create table student (id int unsigned auto_increment primary key,name varchar(10) not null,gender enum(&#39;f&#39;,&#39;m&#39;) default &#39;m&#39;,age tinyint unsinged,mobile char(10),address varchar(50)); 通过查询现存表创建；新表会被直接插入查询而来的数据CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,…)] [table_options][partition_options] select_statement create table employee select * from student; 通过复制现存的表的表结构创建，但不复制数据CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name { LIKE old_tbl_name | (LIKE old_tbl_name) } create table custom like student; 查看所有的引擎：SHOW ENGINES 查看表：SHOW TABLES [FROM db_name] 查看表结构：DESC [db_name.]tb_nameSHOW COLUMNS FROM [db_name.]tb_nameshow columns from student; 删除表：DROP TABLE [IF EXISTS] tb_name 查看表创建命令：SHOW CREATE TABLE tbl_name 查看表状态：SHOW TABLE STATUS LIKE ‘tbl_name’ 查看库中所有表状态：SHOW TABLE STATUS FROM db_name 查看表上的索引：SHOW INDEXES FROM [db_name.]tbl_name; 查看帮助：Help ALTER TABLE]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS]]></title>
    <url>%2F2018%2F11%2F25%2FDNS%2F</url>
    <content type="text"><![CDATA[DNS服务DNS:Domain Name Service 应用层协议，属于 C/S 结构，端口号：udp/53,tcp/53 安装包 yum install bind DNS域名分类根域一级域名二级域名三级域名最多127级域名 DNS查询类型 递归查询 迭代查询 解析类型FQDN –&gt; IPIP –&gt; FQDN DNS服务器的类型 主DNS服务器 从DNS服务器 缓存DNS服务器（转发器） DNS解析一次完整的查询请求经过的流程：Client –&gt;hosts文件 –&gt;DNS Service Local Cache –&gt; DNS Server (recursion) –&gt; Server Cache –&gt; iteration(迭代) –&gt; 根–&gt; 顶级域名DNS–&gt;二级域名DNS… 解析答案 解析答案： 肯定答案： 否定答案：请求的条目不存在等原因导致无法返回结果 权威答案： 非权威答案： bind服务器配置文件服务脚本 /etc/rc.d/init.d/named;/usr/lib/systemd/system/named.service 主配置文件：/etc/named.conf;/etc/named.rfc1912.zones;/etc/rndc.key 解析库文件：/var/named/ZONE_NAME.ZONE 一台物理服务器可同时为多个区域提供解析 必须要有根区域文件，named.ca 应用有两个（如果包括ipv6会更多）实现localhost和本地回环地址的解析库]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全和加密]]></title>
    <url>%2F2018%2F11%2F18%2FSecure_and_Encrypt%2F</url>
    <content type="text"><![CDATA[安全机制信息安全防护的目标 保密性 完整性 可用性 可控制性 不可否认性安全防护环节 物理安全：各种设备主机，机房环境 系统安全：主机或设备的操作系统 应用安全：各种网络服务，应用程序 网络安全：对网络访问的控制，防火墙规则 数据安全：信息的备份与恢复，加密解密 管理安全：各种保障性的规则，流程，方法 安全算法安全技术 认证 授权 审计 安全通信加密算法和协议 对称加密 公钥加密 单向加密 认证协议 加密算法对称密钥加密算法特性： 加密和解密使用同一个密钥，效率高 将原始数据分割成固定大小的块，逐个进行加密 缺陷： 密钥过多 传输困难，密钥难以分发 数据来源无法确认 加密算法 DES:Data Encryption Standard，56bits 3DES AES：Advanced (128, 192, 256bits) Blowfish,Twofish IDEA,RC6,CAST5 非对称密钥加密算法特点： 密钥成对出现 公钥(public key)公开给所有人，私钥(secret key)自己留存，必须保证其私密性 用公钥加密数据，只能使用与之对应的私钥解密，反之亦然 缺点：密钥长，加密、解密效率低 功能： 数字签名：主要用于让接收方确认发送方的身份 对称密钥交换：发送方用对方的公钥加密一个对称密钥后发送给对方 数据加密：适合加密较小数据 加密算法 RSA（用于加密，数字签名） DSA（数字签名） ELGamal 单向加密算法单向散列算法 将任意数据缩小成固定大小的“指纹”特点： 任意长度输入 固定长度输出 若修改数据，指纹也会改变（不会产生冲突） 无法从指纹中重新生成数据（单向） 功能：确保数据完整性 加密算法md5:128bits，sha1:160bit，ssh224，sha256，sha384，sha512 算法组合1、非对称Pa[Sb[data]] 2、非对称+hashPa[data+Sb[hash(data)]] 3、对称+非对称+hashkey[data+Sb[hash(data)]]+Pa[key] 工具md5sum | sha1sum [–check] file SSL协议分为握手阶段和应用阶段 握手阶段(协商阶段): 客户端和服务器端认证对方身份（依赖于PKI体系，利用数字证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。后续通信使用的所有密钥都是通过MasterSecret生成。 应用阶段: 在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信 Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身份认证可选）、密钥交换 ChangeCipherSpec 协议：一条消息表明握手协议已经完成 Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告 Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等 HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合 HTTP over SSL”或“HTTP over TLS” HTTPS结构 HTTPS工作过程]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWK]]></title>
    <url>%2F2018%2F11%2F10%2FAWK%2F</url>
    <content type="text"><![CDATA[AWK 文本报告生成器AWK 是行处理工具，每次处理一条记录。CentOS 中默认使用 GNU awk（gawk） AWK 用法awk [options] ‘program’ var=value file…awk [options] -f programfile var=value file…awk [options] ‘BEGIN{action;… }pattern{action;… }END{action;… }’ file … awk 程序可由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共3部分组成program 通常是被放在单引号中 AWK 基本格式awk [options] ‘program’ file… Program：pattern{action statements;..} awk 和grep，sed一样，都是逐行处理 -F “分隔符” awk默认的分隔字段的分隔符为空白符（空格，换行，制表符） 默认输出分隔符为空格 分隔符支持正则表达式1df |awk -F&apos;[ %]+&apos; &apos;/^\/dev\/sd/&#123;print $5&#125;&apos; pattern 模式pattern部分决定动作语句何时触发及触发事件 BEGIN,END action 动作action statements对数据进行处理，放在{}内指明 print, printf 分隔字段（域）的分隔符：$1,$2,…$n, $0为所有域，和shell中的变量$符的含义不同 BEGIN 用于初始化，打印表头不添加文件时可以只打印一遍输出内容 END 用于信息汇总，打印结果 省略action 部分默认执行 print $0 操作 action 部分不加引号会识别为变量，如果要打印字符串需要加引号1234[root@centos7-1 data]#awk -v n=&quot;abc&quot; &apos;BEGIN&#123;print n&#125;&apos;abc[root@centos7-1 data]#awk -v n=&quot;abc&quot; &apos;BEGIN&#123;print &quot;n&quot;&#125;&apos;n action 可以数字运算，如果加“ ” 会识别为字符串1234[root@centos7-1 data]#awk &apos;BEGIN&#123;print 1+2&#125;&apos;3[root@centos7-1 data]#awk &apos;BEGIN&#123;print &quot;1+2&quot;&#125;&apos;1+2 AWK 变量-v var=value 变量赋值 内置变量FS：输入字段分隔符，默认为空白字符12awk -v FS=&apos;:&apos; &apos;&#123;print $1,FS,$3&#125;’ /etc/passwdawk –F: &apos;&#123;print $1,$3,$7&#125;’ /etc/passwd OFS：输出字段分隔符，默认为空白字符1awk -v FS=‘:’ -v OFS=‘:’ &apos;&#123;print $1,$3,$7&#125;’ /etc/passwd RS：输入记录分隔符，指定输入时的换行符1awk -v RS=&apos; &apos; ‘&#123;print &#125;’ /etc/passwd ORS：输出记录分隔符，输出时用指定符号代替换行符1awk -v RS=&apos; &apos; -v ORS=&apos;###&apos;‘&#123;print &#125;’ /etc/passwd NF：字段数量12awk -F：‘&#123;print NF&#125;’ /etc/fstab #引用变量时，变量前不需加$awk -F：‘&#123;print $(NF-1)&#125;&apos; /etc/passwd NR：记录号12345678awk ‘&#123;print NR&#125;’ /etc/fstab ; awk END‘&#123;print NR&#125;’ /etc/fstabawk -F: &apos;&#123;print NR,$1&#125;&apos; /etc/passwd /etc/group #记录号显示的是两个文件一起排序的结果1 root2 bin...43 root44 bin FNR：各文件分别计数,记录号1awk &apos;&#123;print FNR&#125;&apos; /etc/fstab /etc/inittab FILENAME：当前文件名1awk &apos;&#123;print FILENAME&#125;’ /etc/fstab ARGC：命令行参数的个数12awk &apos;&#123;print ARGC&#125;’ /etc/fstab /etc/inittabawk ‘BEGIN &#123;print ARGC&#125;’ /etc/fstab /etc/inittab ARGV：数组，保存的是命令行所给定的各参数12awk ‘BEGIN &#123;print ARGV[0]&#125;’ /etc/fstab /etc/inittabawk ‘BEGIN &#123;print ARGV[1]&#125;’ /etc/fstab /etc/inittab 自定义变量自定义变量字符区分大小写(1) -v var=value12awk -v test=&apos;hello gawk&apos; &apos;&#123;print test&#125;&apos; /etc/fstabawk -v test=&apos;hello gawk&apos; &apos;BEGIN&#123;print test&#125;&apos; (2) 在program中直接定义12awk &apos;BEGIN&#123;test=&quot;hello,gawk&quot;;print test&#125;&apos;awk -F:‘&#123;sex=“male”;print $1,sex,age;age=18&#125;’ /etc/passwd 把awk 放到文件中123vim awk.txt&#123;print $1&#125;awk -F: -f awk.txt /etc/passwd printf 格式化输出printf 在shell中也有，属于内部命令 格式：printf “FORMAT”, item1, item2, … 必须指定FORMAT 不会自动换行，需要显式给出换行控制符，\n FORMAT中需要分别为后面每个item指定格式符格式符：与item一一对应 %c：显示字符的ASCII码 %d, %i：显示十进制整数 %e, %E：显示科学计数法数值 %f：显示为浮点数 %g, %G：以科学计数法或浮点形式显示数值 %s：显示字符串 %u：无符号整数 %%：显示%自身 修饰符m[.n] 第一个m控制显示的宽度；第二个n表示小数点后精度，%3.1f - 左对齐（默认右对齐） %-15s + 显示数值的正负符号 %+d1[root@centos7-1 data]#awk -F: &apos;BEGIN&#123;print &quot;-----------------------------\n|username |uid |&quot;&#125;&#123;printf &quot;-----------------------------\n|%-20s |%-5d|\n&quot;,$1,$3&#125;END&#123;print &quot;+---------------------------+&quot;&#125;&apos; /etc/passwd 算术操作符x+y, x-y, x*y, x/y, x^y, x%y -x：转换为负数 +x：将字符串转换为数值字符串操作符：没有符号的操作符，字符串连接 赋值操作符：=, +=, -=, *=, /=, %=, ^=，++, –1234[root@centos7-1 data]#awk &apos;BEGIN&#123;i=0;print ++i,i&#125;&apos;1 1[root@centos7-1 data]#awk &apos;BEGIN&#123;i=0;print i++,i&#125;&apos;0 1 比较操作符：==, !=, &gt;, &gt;=, &lt;, &lt;= 模式匹配符：~：左边是否和右边匹配!~：是否不匹配 逻辑操作符：与&amp;&amp;，或||，非!逻辑判断写在括号外面，属于PATTERN1234awk -F: &apos;$3&gt;=0 &amp;&amp; $3&lt;=1000 &#123;print $1&#125;&apos; /etc/passwdawk -F: &apos;$3==0 || $3&gt;=1000 &#123;print $1&#125;&apos; /etc/passwdawk -F: &apos;!($3==0) &#123;print $1&#125;&apos; /etc/passwdawk -F: &apos;!($3&gt;=500) &#123;print $3&#125;&apos; /etc/passwd 条件表达式（三目表达式）selector?if-true-expression:if-false-expression1[root@centos7-1 data]#awk -F: &apos;$3&gt;=1000?name=&quot;common user&quot;:name=&quot;system user&quot;&#123;print name,$1,$3&#125;&apos; /etc/passwd PATTERN(1)如果未指定：空模式，匹配每一行 (2) /regular expression/：仅处理能够模式匹配到的行，需要用/ /括起来12awk &apos;/^UUID/&#123;print $1&#125;&apos; /etc/fstabawk &apos;!/^UUID/&#123;print $1&#125;&apos; /etc/fstab 12345678lastb |awk &apos;$3 ~ /^[[:digit:]]/&#123;print $3&#125;&apos;awk -F: &apos;i=1;j=1&#123;print i,j&#125;&apos; /etc/passwdawk ‘!0’ /etc/passwd ; awk ‘!1’ /etc/passwdAwk -F: &apos;$3&gt;=1000&#123;print $1,$3&#125;&apos; /etc/passwdawk -F: &apos;$3&lt;1000&#123;print $1,$3&#125;&apos; /etc/passwdawk -F: &apos;$NF==&quot;/bin/bash&quot;&#123;print $1,$NF&#125;&apos; /etc/passwdawk -F: &apos;$NF ~ /bash$/&#123;print $1,$NF&#125;&apos; /etc/passwdlastb |awk &apos;$3 ~ /^[[:digit:]]/&#123;print $3&#125;&apos; |sort |uniq -c |awk &apos;$1&gt;3&#123;print $1,$2&#125;&apos; (3) relational expression: 关系表达式，结果为“真”才会被处理 真：结果为非0值，非空字符串假：结果为空字符串或0值123456seq 10 | awk &apos;i=0&apos;seq 10 | awk &apos;i=1&apos;seq 10 | awk &apos;i=!i&apos; #打印奇数行seq 10 | awk &apos;&#123;i=!i;print i&#125;&apos;seq 10 | awk &apos;!(i=!i)&apos; #打印偶数行seq 10 |awk -v i=1 ‘i=!i’ #打印偶数行 (4) line ranges：行范围123startline,endline：/pat1/,/pat2/ 不支持直接给出数字格式awk -F: &apos;/^root\&gt;/,/^nobody\&gt;/&#123;print $1&#125;&apos; /etc/passwdawk -F: &apos;(NR&gt;=10&amp;&amp;NR&lt;=20)&#123;print NR,$1&#125;&apos; /etc/passwd (5) BEGIN/END模式BEGIN{}：仅在开始处理文件中的文本之前执行一次END{}：仅在文本处理完成之后执行一次 if-else 条件判断语法：if(condition){statement;…}[else statement] if(condition1){statement1}else if(condition2){statement2}else{statement3} 对awk取得的整行或某个字段做条件判断12awk &apos;BEGIN&#123; test=100;if(test&gt;90)&#123;print &quot;very good&quot;&#125;else if(test&gt;60)&#123; print ”good”&#125;else&#123;print &quot;no pass&quot;&#125;&#125;&apos; while 循环while循环语法：while(condition){statement;…}条件“真”，进入循环；条件“假”，退出循环 对一行内的多个字段逐一类似处理时使用对数组中的各元素逐一处理时使用1[root@centos7-1 data]#awk -F: &apos;NR==1&#123;i=1;while(i&lt;=NF)&#123;print $i,length($i);i++&#125;&#125;&apos; /etc/passwd 1[root@centos7-1data]#awk-F, &apos;&#123;i=1;max=$1;min=$1;while(i&lt;=NF)&#123;if($i&gt;max)&#123;max=$i&#125;else if($i&lt;min)&#123;min=$i&#125;i++&#125;&#125;END&#123;print &quot;max=&quot;max,&quot;min=&quot;min&#125;&apos; f3.txt do-while 循环do-while循环语法：do {statement;…}while(condition) 意义：无论真假，至少执行一次循环体1awk &apos;BEGIN&#123; total=0;i=0;do&#123; total+=i;i++;&#125;while(i&lt;=100);print total&#125;&apos; for 循环for循环语法：for(expr1;expr2;expr3) {statement;…} 特殊用法：能够遍历数组中的元素语法：for(var in array) {for-body} switch语法：switch(expression) {case VALUE1 or /REGEXP/: statement1; case VALUE2 or /REGEXP2/: statement2; …; default: statementn} break12awk ‘BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;if(i==66)break;sum+=i&#125;print sum&#125;&apos; 12[root@centos7-1 ~]#awk &apos;BEGIN&#123;total=0;for(i=1;i&lt;=100;i++)&#123;if(i==50)break;total+=i&#125;;print total&#125;&apos;1225 continue12awk ‘BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;if(i%2==0)continue;sum+=i&#125;print sum&#125;&apos; 12[root@centos7-1 ~]#awk &apos;BEGIN&#123;total=0;for(i=1;i&lt;=100;i++)&#123;if(i==50)continue;total+=i&#125;;print total&#125;&apos;5000 next提前结束对本行处理而直接进入下一行处理（awk自身循环）1[root@centos7-1 ~]#awk -F: &apos;&#123;if(NR%2==0)next;print NR,$0&#125;&apos; /etc/passwd 数组awk 中用的都是关联数组 关联数组：array[index-expression] index-expression: 可使用任意字符串；字符串要使用双引号括起来 如果某数组元素事先不存在，在引用时，awk会自动创建此元素，并将其值初始化为“空串” 若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历 12awk &apos;BEGIN&#123;weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]&#125;&apos; 1234567[root@centos7-1 ~]#echo -e &quot;abc\nabc\nbbb\nccc\nccc\nccc\nddd&quot;|awk &apos;&#123;!line[$0]++;print $0,line[$0]&#125;&apos;abc 1abc 2bbb 1ccc 1ccc 2ccc 3ddd 1 遍历数组中的每个元素for(var in array) {for-body} 注意：var会遍历array的每个索引，从数组元素中取下标 数组遍历的打印结果是无序的 12netstat -tan | awk &apos;/^tcp/&#123;state[$NF]++&#125;END&#123;for(i in state) &#123; print i,state[i]&#125;&#125;&apos; 1ss -nt|awk -F&quot;[[:space:]:]+&quot; &apos;/ESTAB/&#123;ip[$(NF-2)]++&#125;END&#123;for(i in ip)&#123;print i,ip[i]&#125;&#125;&apos; 函数内置函数rand(): 返回0和1之间一个随机数12[root@centos7-1 data]#awk &apos;BEGIN&#123;srand();print rand()&#125;&apos;0.126253 12[root@centos7-1 data]#awk &apos;BEGIN&#123;srand();print int(rand()*100)&#125;&apos;62 length([s])：返回指定字符串的长度sub(r,s,[t])：对t字符串搜索r表示模式匹配的内容，并将第一个匹配内容替换为s1echo &quot;2008:08:08 08:08:08&quot; | awk &apos;sub(/:/,&quot;-&quot;,$1)&apos; gsub(r,s,[t])：对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容1echo &quot;2008:08:08 08:08:08&quot; | awk ‘gsub(/:/,&quot;-&quot;,$0)&apos; split(s,array,[r])：以r为分隔符，切割字符串s，并将切割后的结果保存至array所表示的数组中，第一个索引值为1,第二个索引值为2,…12netstat -tn | awk &apos;/^tcp\&gt;/&#123;split($5,ip,&quot;:&quot;);count[ip[1]]++&#125;END&#123;for (i in count) &#123;print i,count[i]&#125;&#125;&apos; 自定义函数格式：function name ( parameter, parameter, … ) {statementsreturn expression}12345678[root@centos7-1 data]#vim fun.awkfunction max(x,y)&#123; x&gt;y?var=x:var=y return var&#125;BEGIN&#123;print max(a,b)&#125; [root@centos7-1 data]#awk -v a=29 -v b=13 -f fun.awk29 system 函数空格是awk中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔，或者说除了awk的变量外其他一律用””引用起来1awk &apos;BEGIN&#123;dir=&quot;/boot&quot;;system(&quot;ls &quot;dir)&#125;&apos; awk 脚本格式：awkfile var=value var2=value2… Inputfile 注意：在BEGIN过程中不可用。直到首行输入完成以后，变量才可用。可以通过-v 参数，让awk在执行BEGIN之前得到变量的值。命令行中每一个指定的变量都需要一个-v参数 读入文件时，变量可以不用加 -v 123456[root@centos7-1 data]#vim f2.awk#!/bin/awk -f#&#123;if($3&gt;=num)print $1,$3&#125;[root@centos7-1 data]#./f2.awk -F: num=1000 /etc/passwdnfsnobody 65534 12345[root@centos7-1 data]#vim f3.awk#!/bin/awk -f&#123;if($3&gt;=min &amp;&amp; $3&lt;=max)print $1,$3&#125; [root@centos7-1 data]#./f3.awk -F: min=100 max=200 /etc/passwdsystemd-network 192]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL脚本编程进阶]]></title>
    <url>%2F2018%2F11%2F04%2FShellProgram2%2F</url>
    <content type="text"><![CDATA[SHELL脚本编程进阶流程控制语句面向过程编程语言： 顺序执行 选择执行 循环执行 if条件选择if COMMANDS; then COMMANDS [ elif COMMANDS; then COMMANDS; ] ... [ else COMMANDS; ] fi case条件判断case 变量引用 in PATTERN) 分支1 ;; PATTERN) 分支2 ;; ... *) 默认分支 ;; esac for循环for NAME [in WORDS ... ] ; do COMMANDS done for (( exp1; exp2; exp3 )); do COMMANDS done ((…))格式可以用于算术运算((…))也可以使bash shell实现C语言风格的变量操作i=10 ; i++控制变量初始化：仅在运行循环代码开始时执行一次控制变量的变化：每轮循环结束会先进行控制变量修正运算，再做条件判断 列表生成方法 直接给出列表 整数列表 {1..10} $(seq 2 2 10) 返回列表的命令 使用通配符 变量引用; $@,$* while循环123while CONDITION; do 循环体done CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后再次做判断；条件为”true”，执行一次循环；条件为”false”，终止循环CONDITION一般应该有循环控制变量，变量的值会在循环体中不断地修正 进入条件：CONDITION true 退出条件：CONDITION false 无限循环while true; do 循环体 done while循环遍历文件的每一行while read line; do 循环体 done &lt; /PATH/FROM/SOMEFILE 依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line 12345#可以给read赋多个变量[root@centos7-1 data]#echo &quot; magedu wang &quot;|while read name;do echo $name;donemagedu wang[root@centos7-1 data]#echo &quot; magedu wang &quot;|while read name name2;do echo $name $name2;donemagedu wang 1234567#命令执行效果不同[root@centos7-1 data]#echo &quot;mage&quot;|read name;echo $name[root@centos7-1 data]#echo &quot;mage&quot;|while read name;echo $name&gt; ^C[root@centos7-1 data]#echo &quot;mage&quot;|while read name;do echo $name;donemage until循环until COMMANDS; do 循环体 done 进入条件：CONDITION false 退出条件：CONDITION true 无限循环until false; do 循环体 done select循环与菜单select适合创建菜单，按数字顺序排列的菜单项显示在标准输出上，并显示PS3提示符，等待用户输入用户输入列表中的数字，执行相应的命令select是个无限循环，因此要用break命令退出循环，或者用exit命令终止脚本，也可以按CTRL+c退出循环select经常和case联合使用可以省略in list，此时使用位置参量 格式： select NAME [in WORDS … ;] do COMMANDS; done select MENU in A B C D; doecho $MENUdone用户输入被保存在内置变量REPLY中，REPLY 是由PS3影响的 示例123456789101112131415161718192021vim menu.shPS3=&quot;Please input a number:&quot; #PS3 提示符select MENU in A B C D E F quit; do case $REPLY in 1|2) echo &quot;A and B&quot; ;; 3|4) echo &quot;C and D&quot; ;; 5|6) echo &quot;E and F&quot; ;; 7) echo &quot;Byebye&quot; break ;; *) echo &quot;Input invalid&quot; esacdone 循环控制语句continue用于循环体中continue[n]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层123456789while CONDITION1; do COMMAND1 ... if CONDITION2; then continue fi COMMANDn ...done 循环控制语句break用于循环体中break[N]：提前结束第N层循环，最内层为第1层123456789while CONDITION1; do COMMAND1 ... if CONDITION2; then break fi COMMANDn ...done shift命令shift[n]用户将参量列表list左移指定次数，缺省为左移一次。参量列表list一旦被移动，最左端的哪个参数就从列表中删除。while循环遍历位置参量列表时，常用到shift12345while [ $# -gt0 ] # or (( $# &gt; 0 )) do echo $* shiftdone 函数函数是由若干条shell命令组成的语句块，实现代码重用和模块化编程 函数和shell脚本的区别执行shell脚本相当于开启了一个shell子进程，程序在子shell中运行shell函数在当前shell中运行，和当前shell进程平级。函数可以对shell中的变量进行修改。函数不能独立运行，而是shell程序的一部分 函数组成函数组成部分： 函数名 函数体 定义函数 f_name (){…函数体…} function f_name {…函数体…} function f_name (){…函数体…} 查看函数定义格式： declare -f function_name12345[root@centos7-1 data]#declare -f is_digitis_digit () &#123; [[ $1 =~ [0-9]+ ]] &amp;&amp; echo true || echo false&#125; 定义函数 交互环境下定义函数 1[root@centos7-1 data]#version()&#123; sed -nr &apos;s/.* ([0-9]+)\..*/\1/p&apos; /etc/centos-release; &#125; 在脚本中定义函数 12345678vim functionsipaddr()&#123; [ &quot;$1&quot; ] || echo &quot;Please input arguments!&quot; while [ $# -gt 0 ]; do ifconfig $1 |sed -nr &apos;2s/[^0-9]+([0-9.]+).*/\1/p&apos; shift done&#125; 函数在使用前必须定义，因此应将函数定义放在脚本开始部分。 函数调用使用其函数名即可。 可以将经常使用的函数存入函数文件，然后将函数文件载入shell脚本中。 文件名可任意选取。 一旦函数文件载入shell，就可以在命令行或脚本中调用函数。 使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数。 若要改动函数，先用unset命令从shell中删除函数，改完后，在重新载入次文件。 载入函数定位函数文件并载入shell的格式 . filename source filename 删除函数格式： unset function_name 环境函数环境函数子进程也可以使用声明： export -f function_name查看： export -f 或 declare -xf 函数引用$(function_name)`function_name` 函数变量环境变量当前shell及子shell进程有效 本地变量，全局变量，普通变量只在当前shell进程有效，对shell子进程无效，执行脚本会启动专用子shell进程 局部变量函数体内部有效函数中定义局部变量local NAME=VALUE如果函数中有局部变量，且名称与本地变量同名，函数内部使用局部变量 函数参数 传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表，“testfunc arg1 arg2” 函数体中，可使用$1,$2,…调用参数；还可以使用$@,$*,$#等特殊变量 函数递归函数直接或间接调用自身求自然数n的阶乘 n!=1x2x3x…x(n-1)xn阶乘可以用递归方式实现 n!=nx(n-1)!, (n-1)!=(n-1)x(n-2)!…n!=nx(n-1)x(n-2)x…x2x112345678910vim fact.shfact()&#123; if [ $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi&#125;fact $1 fork炸弹fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质上是一个简单的递归程序。由于是递归程序，如果没有任何限制，这会导致这个程序迅速消耗尽系统里的所有资源。 函数实现： :(){:|:&amp;};:bomb() { bomb | bomb&amp; }; bomb]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL脚本编程基础]]></title>
    <url>%2F2018%2F11%2F04%2FShellProgram1%2F</url>
    <content type="text"><![CDATA[SHELL脚本编程shell脚本：包含一些命令或声明，并符合一定格式的文本文件 格式要求：首行shebang机制123#!/bin/bash#!/usr/bin/python#!/usr/bin/perl shell脚本的用途有 自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 脚本规范脚本代码开头约定 第一行一般为调用使用的语言 程序名，避免更改文件名为无法找到正确的文件 版本号 更改后的时间 作者相关信息 该程序的作用，及注意事项 最后是各版本的更新简要说明 脚本的基本结构#!SHEBANG CONFIGURATION_VARIABLES FUNCTION_DEFINITIONS MAIN_CODE 脚本调试检查脚本中的语法错误 bash -n /path/to/some_script 调试执行 bash -x /path/to/some_script 变量变量命名规则 变量名是由字母，数字，下划线组成，并且不能以数字开头 变量名区分大小写 不能使用程序中的关键字，例如if，for 做到见名知义 统一命名规范 变量作用 数据存储格式 参与的运算 表示的数据范围 变量存储类型字符数值：整数 弱类型语言在运行时会因是做数据类型转换。无需指定类型，默认均为字符型，参与运算会自动进行隐式类型转换；变量无须事先定义即可直接调用。 bash 是一种弱类型语言，但不支持浮点数，类似语言还有如 php,javascript 注意事项 变量名与等号之间，等号与变量值之间不要有空格 只有在引用变量的时候，才在变量名之前加$，其他情况，比如删除、赋值、循环迭代都不用加$ 如果一行只有一条命令，则每一行不用以分号结尾，每一条命令以换行分隔 如果一行有多条命令，则每一条命令以分号分隔，但建议每行只有一条命令 bash中变量的种类 环境（全局）变量：生效范围为shell进程及其子进程 局部变量：生效范围为当前shell进程，对当前shell进程之外的其他shell进程，包括当前shell进程的子进程均无效 本地变量：生效范围为当前shell进程中函数内部 位置变量：$1,$2,…来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数 特殊变量：$?,$0,$*,$@,$#,$$ 环境变量变量声明和赋值： export name=VALUEdeclare -x name=VALUE 变量引用：$name, ${name} 显示所有环境变量： env printenv export declare -x 删除变量：unset name 局部变量变量赋值： name=&#39;VALUE&#39; 直接是字符串：name=”root” 变量引用：name=”$USER” 命令引用：name=`COMMAND`,name=$(COMMAND) 变量引用： ${name},$name “”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串 显示已定义的所有变量：set 删除变量：unset name]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F2018%2F10%2F30%2FNetworkProtocol%2F</url>
    <content type="text"><![CDATA[网络什么是网络？网络是把各种设备连接起来，按照一定的通讯协议，进行通讯的集合。 网络物理拓扑结构 总线拓扑 环状拓扑 星型拓扑 扩展星型拓扑 网状拓扑 双环拓扑 OSI参考模型 应用层 application 表示层 persention 会话层 session 传输层 transport 网络层 network 数据链路层 data link 物理层 physical 网络模型分层的意义 降低复杂性 标准化接口 简化模块化设计 确保技术的互操作性 加快发展速度 简化教学 PDU Protocol Data Unit协议数据单元是指对等层次之间传递的数据单位 物理层的PDU是数据位 bit 数据链路层的PDU是数据帧 frame 网络层的PDU是数据包 packet 传输层的PDU是数据段 segment 其他更高层次的PDU是消息 message 通讯模式 单播 广播 组播 LAN 组成 计算机 PCs Servers 网络互联 NICs Media 网络设备 Hubs Switches Routers Protocols Ethernet IP ARP DHCP Ethernet Frame 结构 Ethernet preamble 8Byte Destination Address 6Byte Source Address 6Byte Type 2Byte Data 46-1500 Byte Fcs 4Byte IEEE 802.3 Preamble 7Byte SOF 1Byte Destination Address 6Byte Source Address 6Byte Type 2Byte Data 46-1500 Byte Fcs 4Byte HUB集线器Hub：多端口中继器 属于物理层设备，它检查帧不是自己的就被抛弃 Hub的特点：共享带宽，半双工 Hub 在网络中对每个端口都转发，flood 泛洪 在Hub上同一时间只有一个信号在传输 Hub 既不隔断冲突域也不隔断广播域 冲突域：当一个主机向网络中发送报文，另一个主机也发送报文，产生冲突，两个主机在一个冲突域中广播域：一个主机发送广播，另一个主机收到，两个主机在一个广播域 交换机 以太网桥任何一个数据报文到达交换机都可以转发，可以转发多路信号交换机能够分析帧结构，属于数据链路层设备 多路信号同时可以传 内置表端口满了以后就广播转发 交换机表中记录的是数据报文的源地址，而广播地址只能作为目标地址，永远不能成为源地址，不可能成为源地址，不能存在MAC地址表中，所以只能泛洪 广播地址表现为 FF:FF:FF:FF:FF:FF 广播地址不会记录在数据表，所以只能泛洪 只能隔断冲突域，不能隔断广播域 路由器路由器属于网络层 多播，广播都被隔断，隔断广播域 可以做安全策略 选择最佳路径，存放路由表，路由策略，路由算法 连接广域网 路由：把一个数据包从一个设备发送到不同网络里的另一个设备上去。这些工作依靠路由器来完成。路由器只关心网络的状态和决定网络中的最佳路径。路由的实现依靠路由器中的路由表来完成 TCP/IP 协议栈Transmission Control Protocol/Internet Protocol传输控制协议/因特网互联协议 TCP/IP是一个Protocol Stack，包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP等许多协议 共定义了四层和ISO参考模型的分层有对应关系 应用层 传输层 Internet层 网络访问层 TCP 特点 工作在传输层 面向连接协议 全双工协议 半关闭 错误检查 将数据打包成段，排序 确认机制 数据恢复，重传 流量控制，滑动窗口 拥塞控制，慢启动和拥塞避免算法 TCP 包头固定长度 20 Byte（单位 bit） 源端口 目的端口 序号 确认号 数据偏移 保留 URG ACK PSH PST SYN FIN 窗口 校验和 紧急指针 16 16 32 32 4 6 1 1 1 1 1 1 16 16 16 TCP 端口号用来标识每个应用程序的地址 0-65535 它是基于 C/S 结构 client/server 常见端口号 ssh C/S tcp 22 http:tcp 80 QQ:udp 8000 https:tcp 443 dhcp:tcp 67,68 snmp:tcp 161 mysql:tcp 3306 oracle:tcp 1521 sql:server:tcp 1433 kerberos:tcp 88 smtp:tcp 25 pop3:tcp 110 imap:tcp 143 smb:tcp 445 有限状态机 FSM:Finite State Machine 状态：描述 CLOSED：无连接是活动 的或正在进行 LISTEN：服务器在等待进入呼叫 SYN_RECV：一个连接请求已经到达，等待确认 SYN_SENT：应用已经开始，打开一个连接 ESTABLISHED：正常数据传输状态 FIN_WAIT1：应用说它已经完成 FIN_WAIT2：另一边已同意释放 ITMED_WAIT：等待所有分组死掉 CLOSING：两边同时尝试关闭 TIME_WAIT：另一边已初始化一个释放 LAST_ACK：等待所有分组死掉 TCP 三次握手TCP 建立连接需要同步，确认三次，俗称三次握手 TCP 四次挥手TCP 断开连接需要四次请求，确认，四次挥手 sync半连接和accept全连接队列 UDP 特性 工作在传输层 提供不可靠的网络访问 非面向连接协议 有限的错误检查 传输性能高 无数据恢复特性 UDP包头（单位 bit） 源地址 目标地址 UDP 长度 UDP 校验和 数据 16 16 16 16 InternetProtocol 特性 运行于OSI网络层 面向无连接的协议 独立处理数据包 分层编址 尽力而为传输 无数据恢复功能 IP 协议报头固定部分 20 Byte(单位 bit) 版本 首部长度 区分服务 总长度 标识 标志 片偏移 生存时间 协议 首部检验和 源地址 目的地址 4 4 8 16 16 3 13 8 8 16 32 32 路由路由器是单向设备 路由表 决定了如何选择一条路径，把收到的数据报文转发到目标主机的所在地 route -n （Linux命令） rout print （Windows命令） 目标网络ID：目标IP所在网络ID 接口：本设备要发送数据包到目标，从那个接口发送出来，才能到达 网关：到达目标网络，需要将数据交给下一个路口哪个接口的对应的IP 主机路由 192.168.32.100/32 优先级高于网络路由 网络路由 192.168.64.0/19 优先级次之 默认路由 0,0,0,0/0 优先级最低 添加默认网关的目的就是为了生成默认路由 动态路由 RIP OSPF BGP ISIS路由协议 RIP 经过的路由器数量越少，就认为最优 OSPF 会考虑带宽]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘和文件系统]]></title>
    <url>%2F2018%2F10%2F21%2FDisk_Filesystem%2F</url>
    <content type="text"><![CDATA[磁盘和文件系统设备文件设备类型 块设备 block，存储单位“块”，代表设备 硬盘 字符设备 char，存储单位“字符”，代表设备 键盘设备文件：关联到一个设备驱动，进而能够跟与之对应硬件设备进行通信设备号码： 主设备号：major number，表示设备类型 次设备号：minor number，标识同一类型下的不同设备 硬盘接口类型 IDE SCSI SATA SAS USB 硬盘类型 机械硬盘（HDD） 固态硬盘（SSD） 设备文件磁盘设备文件的命名：SCSI,SATA,SAS,IDE,USB /dev/sd 不同磁盘标识：a-z,aa,ab… /dev/sda,/dev/sdb,… 同一设备上的不同分区：以数字划分 1,2… /dev/sda1，/dev/sda5 虚拟磁盘：/dev/vd 磁盘寻址方式 CHS 采用24bit位寻址 其中前8位表示head，中间6位标识sector，后面10位表示cylinder 这种结构最大寻址空间为8GB LBA LBA是一个整数，通过转换成CHS格式完成磁盘具体寻址 ATA-1规范中定义了28位寻址模式，以每扇区512位组来计算，ATA-1所定义的28位LBA上限达到128GB。2002年ATA-6规范采用48位LBA，同样以每扇区512位组计算容量上限可达128PetaBytes。在磁盘容量小于8GB时，使用CHS寻址方式或是LBA寻址方式，在磁盘容量大于8GB时，只能使用LBA寻址方式。 磁盘分区为什么要分区？ 优化I/O性能 实现磁盘空间配额限制 提高修复速度 隔离系统和程序 安装多个OS 采用不同文件系统 分区结构分区方式：MBR, GPT MBR 分区结构支持4个主分区或3个主分区+1个扩展分区（N个逻辑分区） 硬盘主引导记录MBR由4个部分组成 主引导程序（偏移地址0000H–0088H），负责从活动分区中装载，并运行系统引导程序 出错信息数据区，偏移地址0089H–00E1H为出错信息，00E2H–01BDH全为0字节 分区表（DPT，Disk Partition Table）含4个分区项，偏移地址01BEH–01FDH,每个分区表项长16个字节，共64字节，分别为分区项1、分区项2、分区项3、分区项4 结束标志字，偏移地址01FEH–01FFH的2个字节值为结束标志55AA GPT 分区结构 GPT:GUID(Globals Unique Ldentifiers) partition table支持128个分区，使用64位，支持8Z（512Byte/block）64Z（4096Byte/block）使用128位UUID（Universally Unique Ldentifier）表示磁盘和分区GPT分区表自动备份在头和尾两份，并有CRC校验位UEFI（同一扩展固件接口）硬件支持GPT，使操作系统启动 分区管理工具lsblk 列出块设备 创建分区 fdisk 创建MBR分区 gdisk 创建GPT分区 parted 高级分区工具 partprobe 重新设置内存中的内核分区表版本 parted 用法parted 操作时实时生效的，小心使用用法：parted [选项]… [设备[命令[参数]…]…]parted /dev/sdbmklabelgpt|msdosparted /dev/sdbprintparted /dev/sdbmkpartprimary 1 200 （默认M）parted /dev/sdbrm1parted –l 列出分区信息 fdisk 用法fdisk-l [-u] [device…] 查看分区fdisk/dev/sdb管理分区 子命令： p 分区列表 t 更改分区类型 n 创建新分区 d 删除分区 v 校验分区 u 转换单位 w 保存并退出 q 不保存并退出 gdisk 和 fdisk 用法类似 查看内核是否已经识别新的分区cat /proc/partations centos6通知内核重新读取硬盘分区表新增分区用partx-a /dev/DEVICEkpartx-a /dev/DEVICE -f: force 删除分区用partx-d –nrM-N /dev/DEVICE CentOS 5，7: 使用partprobepartprobe[/dev/DEVICE]]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Linux，存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SED 工具]]></title>
    <url>%2F2018%2F10%2F13%2FSed%2F</url>
    <content type="text"><![CDATA[SED 工具SED 工具介绍SED （Stream Editor） 行编辑器SED 是一种基于流的编辑工具，每次只能处理一行内容。它的工作原理是，每次读入一行，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区中的内容打印到屏幕。SED 命令默认打印当前读入的行。之后再读入下一行，执行下一次循环。如果没有使诸如‘D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。不断重复上述操作，直到文件末尾。文件内容本身并没有改变，只是打印了出来，除非你使用重定向存储输出。 SED 工具不用打开文件交互操作，通过命令行直接对文件进行过滤，修改，实现了自动编辑一个或多个文件，简化对文件的反复操作，可以编写脚本。 参考：http://www.gnu.org/software/sed/manual/sed.html SED 工具用法用法：sed [OPTION]… {script-only-if-no-other-script} [input-file]… 常用选项：-n 不输出模式空间内容到屏幕-e 多点编辑-f /PATH/SCRIPT_FILE 从指定文件中读取编辑脚本-r 支持使用扩展正则表达式-i 备份文件并原处编辑 地址定界： 不给定地址：全文处理 单地址：#：指定的行；$：最后一行；/pattern/：被模式所能够匹配到的每一行 地址范围：#,#; #,+#; /pat1/,/pat2/; #,/pat1/ ~ 步进：1~2 奇数行；2~2 偶数行 注意：给定地址，或模式匹配后，要跟编辑命令，否则会报丢失命令 编辑命令： d 删除模式空间的行，并立即启用下一轮循环 1sed &apos;/^#/d&apos; /etc/fstab p 打印当前模式空间内容，追加到默认输出之后 1sed &apos;2p&apos; /etc/passwd a [] text 在指定行后面追加文本，支持使用\n实现多行追加 12sed &apos;&apos;/root/a\superman&apos; /etc/passwdsed -i.bak &apos;/^root/a\ admin line&apos; passwd #追加空格开头的字符串，用\ 做分界 i [] text 在行前面插入文本 1sed &apos;/root/i\superman&apos; /etc/passwd c [] text 替换行为单行或多行 1sed &apos;/root/c\superman&apos; /etc/passwd w /path/file 保存模式匹配的行至指定文件 1sed -n &apos;/^UUID/w /data/dir1/ft1&apos; /etc/fstab r /path/file 读取指定文件的文本至模式空间中匹配到的行后 1sed -n &apos;/^UUID/p;$r /data/dir1/grub&apos; /etc/fstab = 为模式空间中的行打印行号 1sed -n &apos;/^$/=&apos; /etc/fstab ！模式空间中匹配行取反处理 1sed -n &apos;/^#/!p&apos; /etc/fstab 查找替换支持使用三种格式 s/// s@@@ s###替换标记： g 行内全部替换 p 显示替换成功的行 w /PATH/FILE 将替换成功的行保存至文件中12sed -n &apos;s/root/&amp;superman/p&apos; /etc/passwd #单词后插入字符串 sed -n &apos;s/root/superman&amp;/p&apos; /etc/passwd #单词前插入字符串 sed 的特殊用法’’’$str’’’ 用来引用变量1str=net.ifnames=0;sed &apos;s/\(^GRUB_CMDLINE_LINUX=.*\)&quot;/\1 &apos;&apos;&apos;$str&apos;&apos;&apos;&quot;/&apos; /etc/default/grub 文件中的小写字母替换为大写字母1sed -r &apos;s/[[:alpha:]]/\u&amp;/g&apos; /data/fstab.bak 文件中的大写字母替换为小写字母1sed -r &apos;s/[[:alpha:]]/\l&amp;/g&apos; /data/fstab.bak \u 表示大写，\l 表示小写 SED 工具的高级用法高级编辑命令： P：打印模式空间开端至\n内容，并追加到默认输出之前 h：把模式空间中的内容覆盖至保持空间中 H：把模式空间中的内容追加至保持空间中 g：从保持空间取出内容覆盖至模式空间 G：从保持空间取出内容追加至模式空间 x：把模式空间中的内容与保持空间中的内容进行互换 n：读取匹配到的行的下一行覆盖至模式空间 N：读取匹配到的行的下一行追加至模式空间 d：删除模式空间中的行 D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环。 sed示例 sed -n ‘n;p’ FILE 显示偶数行 123456[root@centos7-1 data]#seq 10 |sed -n 'n;p'246810 sed ‘1!G;h;$!d’ FILE 逆序显示行 1234567891011[root@centos7-1 data]#seq 10 |sed '1!G;h;$!d'10987654321 sed ‘N;D’FILE 显示最后一行 12[root@centos7-1 data]#seq 10 |sed 'N;D'10 sed ‘$!N;$!D’ FILE 显示最后两行 123[root@centos7-1 data]#seq 10 |sed '$!N;$!D'910 sed ‘$!d’ FILE 显示最后一行 12[root@centos7-1 data]#seq 10 |sed '$!d'10 sed ‘G’ FILE 奇数行之后追加一个空行 1234567891011121314151617181920[root@centos7-1 data]#seq 10 |sed 'G'12345678910 sed ‘g’ FILE 显示相应文本行数的空行 1[root@centos7-1 data]#seq 10 |sed 'g' sed ‘/^$/d;G’ FILE 每行文本下面显示一个空行 123456789101112131415[root@centos7-1 dir1]#cat f1UUID=a9e2060d-678e-47bd-b2ce-98a73101f123 / xfs defaults 0 0UUID=a1fee27e-f745-415e-a406-c02e51f62ef1 /boot xfs defaults 0 0UUID=c9ae8656-7635-476c-b8f3-f372f0997cac /data xfs defaults 0 0UUID=8193094f-203d-4682-800f-486bd5bc7540 swap swap defaults 0 0[root@centos7-1 dir1]#sed '/^$/d;G' f1UUID=a9e2060d-678e-47bd-b2ce-98a73101f123 / xfs defaults 0 0UUID=a1fee27e-f745-415e-a406-c02e51f62ef1 /boot xfs defaults 0 0UUID=c9ae8656-7635-476c-b8f3-f372f0997cac /data xfs defaults 0 0UUID=8193094f-203d-4682-800f-486bd5bc7540 swap swap defaults 0 0 sed ‘n;d’ FILE 显示奇数行 1234567[root@centos7-1 dir1]#seq 10 |sed 'n;d'13579[root@cento sed -n ‘1!G;h;$p’ FILE 逆序显示行 1234567891011[root@centos7-1 dir1]#seq 10 |sed -n '1!G;h;$p'10987654321 打印奇数行123seq 10 | sed -n &apos;1~2p&apos;seq 10 | sed &apos;1~2d&apos;seq 10 | sed &apos;n;d&apos; 打印偶数行123seq 10 | sed -n &apos;2~2p&apos;seq 10 | sed &apos;2~2!d&apos;seq 10 | sed -n &apos;n;p&apos; 倒序显示123seq 10 | tacseq 10 | sed &apos;1!G;h;$!d&apos;seq 10 | sed -n &apos;1!G;h;$p&apos; 练习1、删除centos7系统/etc/grub2.cfg文件中所有以空白开头的行行首的空白字符1sed &apos;s/^[[:space:]]\+\(.*\)/\1/&apos; /etc/grub2.cfg 2、删除/etc/fstab文件中所有以#开头，后面至少跟一个空白字符的行的行首的#和空白字符1sed &apos;s/^# \+\(.*\)/\1/&apos; /etc/fstab 3、在centos6系统/root/install.log每一行行首增加#号1sed &apos;s/.*/#&amp;/&apos; /root/install.log 4、在/etc/fstab文件中不以#开头的行的行首增加#号1sed &apos;s/^[^#]\(.*\)/#\1/&apos; /etc/fstab 5、处理/etc/fstab路径,使用sed命令取出其目录名和基名12echo /etc/fstab/ | sed &apos;s@\(.\+\)/\(.\+\)/\?@\1@&apos;echo /etc/fstab/ | sed &apos;s@\(.\+\)/\(.\+\)/\?@\2@&apos; 6、利用sed 取出ifconfig命令中本机的IPv4地址1234ifconfig eth0 |sed -nr &apos;2s/^.+inet [[:alpha:]:]*(.*) [[:alpha:]]+.* .*/\1/p&apos;ifconfig eth0 |sed -nr &apos;2s/^.+ [[:alpha:]:]*(.*) [[:alpha:]]+.* .*/\1/p&apos;ifconfig eth0 |sed -n &apos;s/^ *inet [[:alpha:]:]*\([0-9.]\+\) .\+ .*/\1/p&apos;ifconfig eth0 |sed -r &apos;2!d;s/.*inet (addr:)?//;s/ (.*)//&apos; 7、统计centos安装光盘中Package目录下的所有rpm文件的以.分隔倒数第二个字段的重复次数1ls /misc/cd/Packages/ | sed -r &apos;s/.*\.(.*)\.rpm$/\1/&apos; |sort |uniq -c |sort -n 8、统计/etc/init.d/functions文件中每个单词的出现次数，并排序（用grep和sed两种方法分别实现）123grep -o &quot;\&lt;[[:alpha:]_]\+\&gt;&quot; /etc/init.d/functions |sort |uniq -c |sort -ngrep -ow &quot;[[:alpha:]_]\+&quot; /etc/init.d/functions |sort |uniq -c |sort -ncat /etc/init.d/functions |sed -nr &apos;s/\&lt;[[:alpha:]_]+\&gt;/\n&amp;\n/gp&apos; |sed -r &apos;/\&lt;[[:alpha:]_]+\&gt;/!d&apos; |sort |uniq -c |sort -n 9、将文本文件的n和n+1行合并为一行，n为奇数行12seq 10 | sed &apos;N;s/\n//&apos;seq 10 | xargs -n2]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户和组的权限管理]]></title>
    <url>%2F2018%2F10%2F07%2FUserMode%2F</url>
    <content type="text"><![CDATA[用户和组的权限管理Linux的安全模型 Authentication:认证 Authorization:授权 Accouting|Audition:审计 用户 userLiunx用户：Username/UID管理员 root普通用户&emsp;&emsp;系统用户&emsp;&emsp;登录用户用户标识：UserID，UID&emsp;&emsp;管理员：0&emsp;&emsp;普通用户：1-60000&emsp;&emsp;系统用户：1-499（CentOS6），1-999（CentOS7）&emsp;&emsp;登录用户：500-60000（CentOS6），1000-60000（CentOS7） 管理员组：root普通用户组&emsp;&emsp;系统组&emsp;&emsp;登录组组标识：GroupID，GID&emsp;&emsp;系统用户：1-499（CentOS6），1-999（CentOS7）&emsp;&emsp;登录用户：500-60000（CentOS6），1000-60000（CentOS7） Linux安全上下文运行中的程序：进程（process）进程所能够访问资源的权限取决于进程的运行者的身份。 Linux用户和组的主要配置文件：/etc/passwd：用户及其属性信息(名称、UID、主组ID等）/etc/group：组及其属性信息/etc/shadow：用户密码及其相关属性/etc/gshadow：组密码及其相关属性 passwd 文件格式name:password:UID:GID:GECOS:directory:shellname:登录用户（wang）passwd:密码（x）UID:用户省份编号（1000）GID:登录默认所在组编号（1000）GECOS:用户全名或注释directory:用户的家目录shell:用户的默认shell，登录式默认shell程序 shadow 文件格式sjj:$6$dsxVEfA9$3Pyz8di/Gr3hfKTzfY/DxyGrd/OnJK0pe51hjnK88SALBT.40pV4urYBKBDSuYt9i/fsFPzwIVmxonHkgXMo/.:17798:0:99999:7:::用户名：用户密码，一般用sha512加密：最近一次修改密码的时间（天数，从1970年1月1日算起）：密码最短使用期限（0表示随时可被改变）：密码最长使用期限（99999表示永不过期）：密码过期警告期限（默认7天）：密码过期几天后账号会被锁定：账号有效期限（从1970年1月1日算起）：保留 group 文件格式group_name:password:GID:user_list组名称：组密码：组的ID：以当前组为附加组的用户列表（分隔符为逗号） gshadow 文件格式组名称：组密码：组管理员的列表，更改组密码和成员：以当前组为附加组的用户列表]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Linux，用户权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬链接与软连接]]></title>
    <url>%2F2018%2F09%2F25%2FPhysicalLink_SymbolicLink%2F</url>
    <content type="text"><![CDATA[硬链接和软连接的区别Linux系统中有硬链接和软链接之分，它们之间究竟什么区别呢，今天在这里总结以下，如有遗漏，不吝赐教。 分析硬链接与软连接的区别，可以从以下8个方面思考， 是否是同一文件 是否支持跨分区 链接数是否增长 结点号是否相同 原始文件删除，链接文件可否访问 链接文件的大小 是否支持目录 是否支持相对路径 不同点 硬链接 软连接 是否指向同一文件 与原文件是同一个文件，表示一个文件起多个文件名 与原文件是不同文件 是否可以跨分区 不支持跨分区 支持跨分区 链接数是否增长 链接数增加 链接数不增加 inode number 是否相同 相同 不同 原文件删除，链接文件是否可以访问 可以 不可以 链接文件与原文件的大小 与原文件大小相同 文件较小，文件大小是路径的大小 是否支持目录 不支持链接到目录 支持链接到目录 文件名支持的相对路径不同 硬链接支持的相对路径是相对于当前工作目录 软连接支持相对路径相对于链接目录 mv命令和ln -s 的区别例 mv /dir1/f1 /dir2/f2mv 命令底层工作原理分为两种情况：1、/dir1 /dir2 在同一分区：mv 命令用新的文件名f2创建对应新的目录项，删除f1目录条目对应的旧的文件名，不影响f1 inode表（除时间戳）或磁盘上的数据位置，数据没有被移动。2、/dir1 /dir2 在不同分区：在目标分区分配一个空闲的inode号，在inode表中生成新条目，在目录中创建一个目录项，将文件名f2与inode编号关联，拷贝f1数据到目标分区生成新的文件。释放源分区f1的inode号，以备重用，链接数递减，把数据块放在空闲列表中，删除源目录项。 例 ln -s /dir1/f1 /dir2/f2ln -s 符号链接底层工作原理不区分是否在同一分区：分配一个新的inode号，inode表中生成新条目，在目录中创建一个目录项，将文件名f2与inode号关联，数据不移动，f2的内容时它引用的f1的路径，f1的inode号不变，f1的链接数不增加或减少。]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>文件，其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理]]></title>
    <url>%2F2018%2F09%2F25%2FFileManagement%2F</url>
    <content type="text"><![CDATA[文件管理文件和目录被组织成一个单根倒置的树结构。文件系统从根目录下开始，用“/”表示。根文件系统（rootfs）文件名称严格区分大小写以.开头的文件为隐藏文件路径以“/”分隔文件有两类数据：元数据：metadata，数据：data文件系统分层结构：LSB Linux Standard BaseFHS: Filesystem Hierarchy Standard 文件名规则文件名最长255个字符包括路径在内文件名称最长4095个字节文件类型可通过颜色区分：蓝色–目录，绿色–可执行文件，红色–压缩文件，浅蓝色–链接文件，白色–普通文件，粉色–socket文件除了“/”和NUL，所有字符都有效在标准Linux 文件系统（如ext4）中，文件名称大小写敏感。在Windows 文件系统（NTFS）中，文件名称大小写不敏感。注意：FAT文件系统，Liunx可以识别，但不区分大小写 文件系统结构 /boot：引导文件存放目录，内核文件（vmlinuz）、引导加载器（bootloader,grub），初始化文件initramfs(initrd) /bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序 /sbin：供系统管理使用的工具程序，不能关联至独立分区，OS启动即会用到的程序 /dev：存储特殊文件或设备文件，设备有两种类型：字符设备（线性设备），块设备（随机设备） /etc：系统程序的配置文件，只能为静态文件 /home：普通用户家目录的集中位置：一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME；（可选目录） /root：管理员的家目录，（可选目录） /lib：为系统启动或根文件系统上的应用程序（/bin,/sbin等）提供共享库，以及为内核提供内核模块（/lib/module 用于存储内核模块的目录） /lib64：64位系统特有的存放64位共享库的路径 /media： 便携式设备挂载点，cdrom，floppy等 /mnt：其他文件系统的临时挂载点 /opt：附加应用程序的安装位置，（可选路径） /srv：当前主机为服务提供的数据 /tmp：为那些会产生临时文件的程序提供的，用于存储临时文件的目录，可供所有用户执行写入操作，有特殊权限 /usr：universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序 sbin: lib：32位使用 lib64：只存在64位系统 include: C程序的头文件(header files) share：结构化独立的数据，例如doc, man等 local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share X11R6：X-Window程序的安装位置 src：程序源码文件的存储位置 /var: variable data files cache: 应用程序缓存数据目录 lib: 应用程序状态信息数据 local：专用于为/usr/local下的应用程序存储可变数据； lock: 锁文件 log: 日志目录及文件 opt: 专用于为/opt下的应用程序存储可变数据； run: 运行中的进程相关数据,通常用于存储进程pid文件 spool: 应用程序数据池 tmp: 保存系统两次重启之间产生的临时数据 /proc：基于内存的虚拟文件系统，用于为内核及进程存储其相关信息：它们多为内核参数 sys：sysfs虚拟文件系统提供了一种比proc 更为理想的访问内核数据的途径；其主要作用在于为管理Linux设备提供一种统一模型的接口 /selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置 应用程序的组成部分二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64配置文件：/etc, /etc/DIRECTORY, /usr/local/etc帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc 文件类型 -：普通文件 d: 目录文件 b: 块设备 c: 字符设备 l: 符号链接文件 p: 管道文件pipe s: 套接字文件socket CentOS7开始/bin,/sbin,/lib,/lib64 这些目录已经变成了软连接12345678[root@centos7-1 ~]#ll /binlrwxrwxrwx. 1 root root 7 Sep 19 13:21 /bin -&gt; usr/bin[root@centos7-1 ~]#ll /sbinlrwxrwxrwx. 1 root root 8 Sep 19 13:21 /sbin -&gt; usr/sbin[root@centos7-1 ~]#ll /liblrwxrwxrwx. 1 root root 7 Sep 19 13:21 /lib -&gt; usr/lib[root@centos7-1 ~]#ll /lib64lrwxrwxrwx. 1 root root 9 Sep 19 13:21 /lib64 -&gt; usr/lib64 pwd: printing working directory-P 显示真实物理路径-L 显示链接路径（默认）123456789101112[root@centos7-1 ~]#pwd -P/root[root@centos7-1 ~]#pwd -L/root[root@centos7-1 ~]#cd /bin[root@centos7-1 bin]#pwd/bin[root@centos7-1 bin]#pwd -P/usr/bin[root@centos7-1 bin]#cd /usr/bin[root@centos7-1 bin]#pwd /usr/bin 绝对路径和相对路径绝对路径 以正斜杠开始 完整的文件的位置路径 可用于任何想指定一个文件名的时候 相对路径名 不以斜线开始 指定相对于当前工作目录或某目录的位置 可以作为一个简短的形式指定一个文件名 基名：basename [root@centos7-1 ~]#basename /etc/profile.d/env.sh env.sh 目录名：dirname [root@centos7-1 ~]#dirname /etc/profile.d/env.sh /etc/profile.d 特殊文件/dev/zero 一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL,ASCLL NUL,0X00)/dev/null 它丢弃一切写入其中的数据，但报告写入操作成功，常被称为位桶(bit bucket)或者黑洞(black hole)/dev/random 产生随机数的设备 基础命令cd 改变目录 使用绝对或相对路径：cd/home/wang/cdhome/wang切换至父目录：cd..切换至当前用户主目录：cd切换至以前的工作目录：cd-123456789101112[root@centos7-1 log]#cd /home/sjj[root@centos7-1 sjj]#cd ..[root@centos7-1 home]#lssjj[root@centos7-1 home]#cd[root@centos7-1 ~]#lsanaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@centos7-1 ~]#cd -/home[root@centos7-1 home]#lssjj touch 创建文件12345678[root@centos7-1 data]#touch '$abc' #创建$abc文件[root@centos7-1 data]#ls$abc[root@centos7-1 data]#touch /data/-a #创建-a文件[root@centos7-1 data]#touch ./-b #创建-b文件[root@centos7-1 data]#touch -- -c #创建-c文件[root@centos7-1 data]#ls-a $abc -b -c ls 列出目录内容用法：ls [options] [files_or_dirs]示例:ls -a包含隐藏文件ls -l显示额外的信息ls -R目录递归通过ls -ld目录和符号链接信息ls -1 文件分行显示ls –S 按从大到小排序ls –t 按mtime排序ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示ls –X 按文件后缀排序 ls 命令列出的文件名默认顺序为 数字，小写字母，大写字母]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>Linux，文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础知识]]></title>
    <url>%2F2018%2F09%2F21%2FLinuxBase%2F</url>
    <content type="text"><![CDATA[Linux基础知识计算机系统计算机是由硬件系统和软件体统组成。硬件系统：根据冯诺依曼体系结构，可以分为运算器（ALU）,控制器，存储器，输入和输出设备。软件系统：系统软件，应用软件。 服务器是计算机的一种，是为客户端提供各种服务的高性能计算机。既可以是具体的计算机硬件，也可以是虚拟的云主机。 操作系统（Operating System）组成部分：硬件驱动，进程管理，内存管理，网络管理，安全管理，文件管理。 用户空间和内核空间用户空间：User space用户程序的运行空间，程序不能直接调用系统资源，必须通过系统接口，执行系统调用，才能向内核发出指令，调用资源。 内核空间：Kernel space是Linux内核的运行空间，用于调用系统资源。 操作系统分类：桌面操作系统，服务器操作系统，移动操作系统。 服务器操作系统：Windows，Linux，Unix 三大类。 Linux最为一款免费使用，自由传播的操作系统，受到越来越多人的青睐，市场占有率逐年上升，所以掌握Linux是成为一名优秀IT人才的必备技能。 Linux与Windows的区别： Linux 最主要的哲学思想是一切皆文件（包括硬件），而Windows则是一切皆图形，所见及所得。 Linux 是开源的，免费使用的操作系统，而Windows是比源的，需要付费获取微软认证才能使用的操作系统。 Linux 是多用户操作系统，同一时间允许多个用户登录，Windows是单用户操作系统。同一时间只允许一个用户登录。 Linux 配置数据存储在文件中，/etc 目录下，Windows配置数据存储在注册表中。 Linux发行版 slackware SLES OpenSuse debian ubuntu mint redhat RHEL CenOS Fedora Android 开源协议GPlv2, GPLv3, LGPL, Apache, BSD, Mozilla, MIT Linux系统使用CentOS系统基础知识用户登录：分为 root用户和普通用户。 终端分类：设备终端，物理终端，虚拟终端，图形终端，串行终端，伪终端。 SHELL是什么 Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口，它把用户输入的命令传入操作系统内核去执行。 Linux的命令解释器（command interpreter） 高级程序设计语言 命令格式：COMMAND [OPTIONS…] [ARGUMENTS…]命令分为内部命令和外部命令。内部命令：shell程序自带的命令，这些命令由shell程序识别并在shell程序内部完成运行，Linux系统启动后shell被加载的系统内存中，其执行速度比外部命令块，CentOS默认使用bash，可以使用echo $SHELL 查看当前使用的shell程序。1234567891011121314151617181920[root@CentOS6-1 ~]#echo $&#123;SHELL&#125;/bin/bash[root@CentOS6-1 ~]#echo $SHELL/bin/bash[root@CentOS6-1 ~]#cat /etc/shells/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh[root@CentOS6-1 ~]#/bin/csh[root@CentOS6-1 ~]# &gt; f1Invalid null command.[root@CentOS6-1 ~]# exitexit[root@CentOS6-1 ~]#&gt; f1[root@CentOS6-1 ~]#lsanaconda-ks.cfg Documents f1 install.log.syslog Pictures TemplatesDesktop Downloads install.log Music Public Videos 查看内部命令12[root@CentOS6-1 ~]#help[root@CentOS6-1 ~]#enable enable 命令1234567[root@centos7-1 ~]#enable -n pwd #禁用内部命令pwd[root@centos7-1 ~]#help*pwd [-LP] # * 代表内部命令已禁用[root@centos7-1 ~]#enable -n #查看所有禁用的内部命令enable -n pwd[root@centos7-1 ~]#enable pwd #启用内部命令[root@centos7-1 ~]#enable -n 外部命令：在文件系统路径下有对应的可执行程序文件1234[root@CentOS6-1 ~]#which cat/bin/cat[root@CentOS6-1 ~]#whereis catcat: /bin/cat /usr/share/man/man1p/cat.1p.gz /usr/share/man/man1/cat.1.gz 查看命令是内部命令还是外部命令,使用type 命令1234[root@CentOS6-1 ~]#type echoecho is a shell builtin[root@CentOS6-1 ~]#type manman is /usr/bin/man Hash表&ensp;&ensp;&ensp;&ensp;系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在就执行，如果不存在，就去PATH路径下寻找。 别名为命令指定一个名字，简化操作，提高效率。1[root@CentOS6-1 ~]#alias vimnet='vim /etc/sysconfig/network-scripts/ifcfg-eth0' 定义的别名仅对当前shell进程有效，想要永久有效，必须保存在配置文件中。 如果别名同原命令同名，要执行原命令，可使用\ALIASNAME“ALIASNAME”‘ALIASNAME’command ALIASNAME/path/command 配置文件有两类配置文件，~/.bashrc对当前用户有效，/etc/bashrc对所有用户有效。这两个文件功用为定义本地变量和命令别名。仅root用户可以修改全局配置文件，普通用户只能修改用户目录下的配置文件。 命令的执行顺序alias(当与内部命令同名时) –&gt; 内部命令(shell) –&gt; hash表(记录执行过的外部命令的路径) –&gt; $PATH –&gt; 提示命令无法找到 注意： 多个选项以及多参数和命令之间使用空白字符分隔 取消和结束命令执行：Ctrl+c，Ctrl+d 多个命令可以用;符号分开 一个命令可以用\分成多行 日期和时间系统时钟，硬件时钟 时间修改格式：date MMDDHHmm[[CC]YY][.ss]例如：date 091921112018.30 查看时区：CentOS6 cat /etc/sysconfig/clockCentOS7 timedatectl | grep “Time zone” hwclock，clock: 显示硬件时钟-s, –hctosys以硬件时钟为准，校正系统时钟-w, –systohc以系统时钟为准，校正硬件时钟 练习1、显示当前时间，格式：2016-06-18 10:20:3012[root@CentOS6-1 ~]#date +"%F %T"2018-09-22 22:07:25 2、显示前天是星期几12[root@CentOS6-1 ~]#date -d "-2 day" +%w4 3、设置当前日期为2019-08-0706:05:101234[root@CentOS6-1 ~]#date 080706052019.10Wed Aug 7 06:05:10 CST 2019[root@CentOS6-1 ~]#date +"%F %T"2019-08-07 06:05:24 同步时间ntpdate xxx.xxx.xxx.xxx（其他主机IP） echo命令echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。 选项： -E （默认）不支持\解释功能 -n 不自动换行 -e 启用\字符的解释功能 echo “$VAR_NAME” 变量会替换，弱引用echo ‘$VAR_NAME’ 变量不会替换，强引用 ‘ ‘ 弱引用，直接引用字符，不取变量值“ “ 强引用，取变量值 , $() 命令引用，把一个命令的输出打印给另一个命令的参数 { } 打印重复字符串123456789101112[root@centos7-1 data]#echo file&#123;1,3,5&#125;file1 file3 file5[root@centos7-1 data]#echo &#123;a..z&#125;a b c d e f g h i j k l m n o p q r s t u v w x y z[root@centos7-1 data]#echo &#123;z..a&#125;z y x w v u t s r q p o n m l k j i h g f e d c b a[root@centos7-1 data]#echo &#123;aa..zz&#125;&#123;aa..zz&#125;[root@centos7-1 data]#echo &#123;aa,bb,cc,dd&#125;aa bb cc dd[root@centos7-1 data]#echo &#123;a,h,e,b,d&#125;a h e b d TAB 键命令补全：用户给定的字符串只有一条惟一对应的命令，直接补全，否则，再次Tab会给出列表路径补全：如果惟一：则直接补全，否则：再次Tab给出列表 命令行历史登录shell时，会读取命令历史文件中记录下的命令~/.bash_history。登录进shell后新执行的命令只会记录在缓存中；这些命令会在用户退出shell时“追加”至命令历史文件中。 重复执行前一条命令的方法： 按上方向键，并回车执行 按!!，并回车执行 输入!-1，并回车执行 按Ctrl+p，并回车执行 !:0 执行前一条命令（除去参数）!n 执行history命令输出对应序号n的命令!-n 执行history历史中倒数第n条命令!string 重复前一个以“string”开头的命令!?string 重复前一个包含“string”的命令!string:p 仅打印命令历史，而不执行!$:p 打印输出!$ （上一条命令的最后一个参数）的内容!:p打印输出!（上一条命令的所有参数）的内容^string删除上一条命令中的第一个string^string1^string2将上一条命令中的第一个string1替换为string2!:gs/string1/string2将上一条命令中所有的string1都替换为string2ctrl-r来在命令历史中搜索命令（reverse-i-search）`’：Ctrl+g：从历史搜索模式退出要重新调用前一个命令中最后一个参数 !$ 表示 Esc, .（点击Esc键后松开，然后点击. 键） Alt+ .（按住Alt键的同时点击. 键） 相关环境变量HISTSIZE：命令历史记录的条数HISTFILE：指定历史文件，默认为~/.bash_historyHISTFILESIZE：命令历史文件记录历史的条数HISTTIMEFORMAT=“%F %T “ 显示时间HISTIGNORE=“str1:str2*:… “ 忽略str1命令，str2开头的历史控制命令历史的记录方式：环境变量：HISTCONTROLignoredups默认，忽略重复的命令，连续且相同为“重复”ignorespace忽略所有以空白开头的命令ignoreboth相当于ignoredups, ignorespace的组合erasedups删除重复命令 bash的快捷键Ctrl + c终止命令Ctrl + d退出Ctrl + l清屏，相当于clear命令Ctrl + o执行当前命令，并重新显示本命令Ctrl + s阻止屏幕输出，锁定Ctrl + q允许屏幕输出Ctrl + c终止命令Ctrl + z挂起命令Ctrl + a光标移到命令行首，相当于HomeCtrl + e光标移到命令行尾，相当于EndCtrl + f光标向右移动一个字符Ctrl + b光标向左移动一个字符Alt + f光标向右移动一个单词尾Alt + b光标向左移动一个单词首Ctrl + xx光标在命令行首和光标之间移动Ctrl + u从光标处删除至命令行首Ctrl + k从光标处删除至命令行尾Alt + r 删除当前整行Ctrl + w从光标处向左删除至单词首Alt + d从光标处向右删除至单词尾Ctrl + d删除光标处的一个字符Ctrl + h删除光标前的一个字符Ctrl + y将删除的字符粘贴至光标后Alt + c从光标处开始向右更改为首字母大写的单词Alt + u从光标处开始，将右边一个单词更改为大写Alt + l从光标处开始，将右边一个单词更改为小写Ctrl + t交换光标处和之前的字符位置Alt + t交换光标处和之前的单词位置Alt + N提示输入指定字符后，重复显示该字符N次注意：Alt组合快捷键经常和其它软件冲突 其他命令startx 切换GUI模式，不提示登录init 5 切换GUI模式，提示登录init 3 切换CLI模式init 0 关机init 6 重启runlevel 查看当前登录类型Linux 中 Ctrl+Alt+[F1-F6] 本地控制台都是字符界面,F7 是图形界面。不过字符界面下面，有的时候 Ctrl 可以不按，Alt + Fx 就可以切换了。 lscpu 查看CPU信息123456789101112131415161718192021222324252627[root@centos7-1 data]#lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 2On-line CPU(s) list: 0,1Thread(s) per core: 1Core(s) per socket: 2Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 142Model name: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHzStepping: 10CPU MHz: 1800.001CPU max MHz: 0.0000CPU min MHz: 0.0000BogoMIPS: 3600.00Hypervisor vendor: VMwareVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 6144KNUMA node0 CPU(s): 0,1Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch epb fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp lsblk,df 查看硬盘分区1234567891011121314151617181920[root@centos7-1 data]#lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 200G 0 disk ├─sda1 8:1 0 1G 0 part /boot├─sda2 8:2 0 50G 0 part /├─sda3 8:3 0 30G 0 part /data├─sda4 8:4 0 1K 0 part └─sda5 8:5 0 4G 0 part [SWAP]sr0 11:0 1 8.8G 0 rom /run/media/root/CentOS 7 x86_64[root@centos7-1 data]#df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 50G 3.9G 47G 8% /devtmpfs 896M 0 896M 0% /devtmpfs 911M 0 911M 0% /dev/shmtmpfs 911M 10M 901M 2% /runtmpfs 911M 0 911M 0% /sys/fs/cgroup/dev/sda3 30G 33M 30G 1% /data/dev/sda1 1014M 165M 850M 17% /boottmpfs 183M 8.0K 183M 1% /run/user/0/dev/sr0 8.8G 8.8G 0 100% /run/media/root/CentOS 7 x86_64 mii-tool 查看网卡信息12[root@centos7-1 data]#mii-tool ens33ens33: negotiated 1000baseT-FD flow-control, link ok free 查看内存信息1234[root@centos7-1 data]#free -h total used free shared buff/cache availableMem: 1.8G 228M 667M 10M 926M 1.3GSwap: 4.0G 264K 4.0G lsb_release -a 查看centos版本（CentOS6）123456[root@CentOS6-1 ~]#lsb_release -aLSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarchDistributor ID: CentOSDescription: CentOS release 6.10 (Final)Release: 6.10Codename: Final cat /etc/centos-release 查看centos版本123456（CentOS6）[root@CentOS6-1 ~]#cat /etc/centos-releaseCentOS release 6.10 (Final)（CentOS7）[root@centos7-1 data]#cat /etc/centos-releaseCentOS Linux release 7.5.1804 (Core) ifconfig 查看本机IP123456789[root@centos7-1 data]#ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.64.130 netmask 255.255.255.0 broadcast 192.168.64.255 inet6 fe80::85ad:5a28:117d:9b02 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:7b:c3:98 txqueuelen 1000 (Ethernet) RX packets 3914 bytes 1339666 (1.2 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1327 bytes 134071 (130.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tty 查看终端设备12[root@centos7-1 data]#tty/dev/pts/0 sleep 延时命令sleep 100 延时100s w 系统当前所有的登录会话及所做的操作1234[root@centos7-1 data]#w 11:11:50 up 2:27, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.64.1 08:52 6.00s 0.61s 0.09s w who 系统当前所有的登录会话123456[root@centos7-1 data]#whoroot pts/0 2018-09-23 08:52 (192.168.64.1)[root@centos7-1 data]#who am iroot pts/0 2018-09-23 08:52 (192.168.64.1)[root@centos7-1 data]#who is aroot pts/0 2018-09-23 08:52 (192.168.64.1) whoami 显示当前登录有效用户12[root@centos7-1 data]#whoamiroot whatis 简要说明命令的功能12345[root@centos7-1 data]#whatis issueissue (5) - prelogin message and identification file[root@centos7-1 data]#whatis lsls (1) - list directory contentsls (1p) - list directory contents du 查看分区容量12[root@centos7-1 data]#du -sh /boot133M /boot ps aux 列出系统中当前运行的进程12345678[root@centos7-1 data]#ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.3 210244 6988 ? Ss 08:44 0:09 /usr/lib/systemd/systemd --switroot 2 0.0 0.0 0 0 ? S 08:44 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 08:44 0:00 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 08:44 0:00 [kworker/0:0H]root 7 0.0 0.0 0 0 ? S 08:44 0:00 [migration/0] pwd 查看当前路径12[root@centos7-1 data]#pwd/data ls 查看当前路径下的文件和文件夹ll 查看当前路径下文件和文件夹的详细信息123456789101112131415[root@centos7-1 ~]#lsanaconda-ks.cfg Documents initial-setup-ks.cfg Pictures TemplatesDesktop Downloads Music Public Videos[root@centos7-1 ~]#lltotal 8-rw-------. 1 root root 1883 Sep 19 13:31 anaconda-ks.cfgdrwxr-xr-x. 2 root root 6 Sep 23 10:22 Desktopdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Documentsdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Downloads-rw-r--r--. 1 root root 1914 Sep 19 13:33 initial-setup-ks.cfgdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Musicdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Picturesdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Publicdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Templatesdrwxr-xr-x. 2 root root 6 Sep 19 13:33 Videos source 或. 使配置文件生效source .bashrc 或 . .bashrc rz 接收文件，sz 发送文件 iconv -l 显示系统中的字符集iconv -f gb2312 w.txt -o l.txt 把GB2312编码转换为Unicode编码1234567891011[root@centos7-1 data]#rz[root@centos7-1 data]#lswin.txt[root@centos7-1 data]#cat win.txt í¸羌Խ[root@centos7-1 data]#iconv -f gb2312 win.txt -o lin.txt[root@centos7-1 data]#lslin.txt win.txt[root@centos7-1 data]#cat lin.txt 马哥教育 hostname 查看主机名id -u 查看当前登录用户的UIDhexdump -C win.txt 显示文件二进制代码123456[root@centos7-1 data]#hexdump -C w.txt00000000 d6 d0 0d 0a |....|00000004[root@centos7-1 data]#hexdump -C l.txt00000000 e4 b8 ad 0d 0a |.....|00000005 nmcli connection modify ens33 connection.autoconnect yes 系统启动后网卡自动连接，（CentOS7） 命令帮助内部命令：help COMMAND 或 man bash外部命令：： COMMAND –helpCOMMAND -h 使用手册(manual)man COMMAND 信息页info COMMAND 程序自身的帮助文档READMEINSTALLChangeLog 程序官方文档官方站点：Documentation 发行版的官方文档 Google –help和-h选项date–helpUsage:date[OPTION]…[+FORMAT]or: date[-u|–utc|–universal][MMDDhhmm[[CC]YY][.ss]][]表示可选项CAPS或&lt;&gt;表示变化的数据…表示一个列表x |y| z的意思是“x或y或z“-abc的意思是-a -b –c{ } 表示分组 man帮助man帮助分为如下章节： 用户命令 系统调用 C库调用 设备文件及特殊文件 配置文件格式 游戏 杂项 管理类的命令 Linux 内核API 段落说明 NAME 名称及简要说明 SYNOPSIS 用法格式说明 []可选内容 &lt;&gt; 必选内容 a|b二选一 { }分组 …同一内容可出现多次 DESCRIPTION 详细说明 OPTIONS 选项说明 EXAMPLES 示例 FILES 相关文件 AUTHOR 作者 COPYRIGHT版本信息 REPORTING BUGS bug信息 SEE ALSO 其它帮助参考 man命令的操作方法：使用less命令实现space, ^v, ^f, ^F: 向文件尾翻屏b, ^b: 向文件首部翻屏d, ^d: 向文件尾部翻半屏u, ^u: 向文件首部翻半屏RETURN, ^N, e, ^E or j or ^J: 向文件尾部翻一行 y or ^Y or ^P or k or ^K：向文件首部翻一行q: 退出 #：跳转至第#行1G: 回到文件首部G：翻至文件尾部 搜索关键字/KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；不区分字符大小写；n: 下一个N：上一个?KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写；n: 跟搜索命令同方向，下一个N：跟搜索命令反方向，上一个 练习1、在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间12345678[root@centos7-1 ~]#nano /etc/issue GNU nano 2.3.1 File: /etc/issue \SKernel \r on an \m\n\l\d \t 2、今天18：30自动关机，并提示用户1[root@CentOS6-1 ~]#shutdown -P 18:30 Server will poweroff at 14:57,please save the data. SCREEN 命令screen 是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。 简单用法创建新screen会话screen –S [SESSION]加入screen会话screen –x [SESSION]退出并关闭screen会话exit剥离当前screen会话Ctrl+a,d显示所有已经打开的screen会话screen -ls恢复某screen会话screen -r [SESSION] screen 的详细用法请参照：screen 命令详解]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
